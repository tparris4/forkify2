(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.msgpackr={}))})(this,function(e){'use strict';var t=Math.floor;function n(){try{if(!F.trusted&&!Y){let e=M.sharedLength||0;e<M.length&&(M.length=e)}let e=s();if(_&&(// bundled strings to skip past
D=_.postBundlePosition),D==E)M.restoreStructures&&r(),M=null,x=null,B&&(B=null);else if(D>E){// over read
let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}else if(!Y)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw M.restoreStructures&&r(),b(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function r(){for(let e in M.restoreStructures)M[e]=M.restoreStructures[e];M.restoreStructures=null}function s(){let e=x[D++];if(160>e){if(!(128>e)){if(!(144>e)){e-=144;let t=Array(e);for(let n=0;n<e;n++)t[n]=s();return t}if(e-=128,F.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[h()]=s();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(s(),s());return t}}else if(64>e)return e;else{let t=M[63&e]||F.getStructures&&o()[63&e];return t?(t.read||(t.read=i(t,63&e)),t.read()):e}}else if(192>e){// fixstr
let t=e-160;if(j>=D)return R.slice(D-v,(D+=t)-v);if(0==j&&140>E){// for small blocks, avoiding the overhead of the extract call is helpful
let e=16>t?g(t):c(t);if(null!=e)return e}return G(t)}else{let t;switch(e){case 192:return null;case 193:return _?(t=s(),0<t?_[1].slice(_.position1,_.position1+=t):_[0].slice(_.position0,_.position0-=t)):W;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:// bin 8
return p(x[D++]);case 197:return t=P.getUint16(D),D+=2,p(t);case 198:return t=P.getUint32(D),D+=4,p(t);case 199:// ext 8
return f(x[D++]);case 200:return t=P.getUint16(D),D+=2,f(t);case 201:return t=P.getUint32(D),D+=4,f(t);case 202:if(t=P.getFloat32(D),2<F.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let e=re[(127&x[D])<<1|x[D+1]>>7];return D+=4,(e*t+(0<t?.5:-.5)>>0)/e}return D+=4,t;case 203:return t=P.getFloat64(D),D+=8,t;// uint handlers
case 204:return x[D++];case 205:return t=P.getUint16(D),D+=2,t;case 206:return t=P.getUint32(D),D+=4,t;case 207:return F.int64AsNumber?(t=4294967296*P.getUint32(D),t+=P.getUint32(D+4)):t=P.getBigUint64(D),D+=8,t;// int handlers
case 208:return P.getInt8(D++);case 209:return t=P.getInt16(D),D+=2,t;case 210:return t=P.getInt32(D),D+=4,t;case 211:return F.int64AsNumber?(t=4294967296*P.getInt32(D),t+=P.getUint32(D+4)):t=P.getBigInt64(D),D+=8,t;case 212:if(t=x[D++],114==t)return Z(63&x[D++]);else{let e=T[t];if(e)return e.read?(D++,e.read(s())):e.noBuffer?(D++,e()):e(x.subarray(D,++D));throw new Error("Unknown extension "+t)}case 213:return t=x[D],114==t?(D++,Z(63&x[D++],x[D++])):f(2);case 214:// fixext 4
return f(4);case 215:// fixext 8
return f(8);case 216:// fixext 16
return f(16);case 217:return t=x[D++],j>=D?R.slice(D-v,(D+=t)-v):H(t);case 218:return t=P.getUint16(D),D+=2,j>=D?R.slice(D-v,(D+=t)-v):J(t);case 219:return t=P.getUint32(D),D+=4,j>=D?R.slice(D-v,(D+=t)-v):K(t);case 220:return t=P.getUint16(D),D+=2,u(t);case 221:return t=P.getUint32(D),D+=4,u(t);case 222:return t=P.getUint16(D),D+=2,d(t);case 223:return t=P.getUint32(D),D+=4,d(t);default:// negative int
if(224<=e)return e-256;if(void 0===e){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+e);}}}function i(e,t){function n(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(2<n.count++){let n=e.read=new Function("r","return function(){return {"+e.map(e=>$.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}}")(s);return 0===e.highByte&&(e.read=q(t,e.read)),n();// second byte is already read, if there is one so immediately read object
}let r={};for(let t,n=0,i=e.length;n<i;n++)t=e[n],r[t]=s();return r}return n.count=0,0===e.highByte?q(t,n):n}function o(){let e=y(()=>(x=null,F.getStructures()));return M=F._mergeStructures(e,M)}function a(e){let t;if(16>e&&(t=g(e)))return t;if(64<e&&L)return L.decode(x.subarray(D,D+=e));const n=D+e,r=[];for(t="";D<n;){const e=x[D++];if(0==(128&e))r.push(e);else if(192==(224&e)){// 2 bytes
const t=63&x[D++];r.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&x[D++],n=63&x[D++];r.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){// 4 bytes
const t=63&x[D++],n=63&x[D++],s=63&x[D++];let i=(7&e)<<18|t<<12|n<<6|s;65535<i&&(i-=65536,r.push(55296|1023&i>>>10),i=56320|1023&i),r.push(i)}else r.push(e);4096<=r.length&&(t+=Q.apply(String,r),r.length=0)}return 0<r.length&&(t+=Q.apply(String,r)),t}function u(e){let t=Array(e);for(let n=0;n<e;n++)t[n]=s();return t}function d(e){if(F.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[h()]=s();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(s(),s());return t}}function c(e){let t=D,n=Array(e);for(let r=0;r<e;r++){const e=x[D++];if(0<(128&e))return void(D=t);n[r]=e}return Q.apply(String,n)}function g(t){if(4>t){if(!(2>t)){let e=x[D++],n=x[D++];if(0<(128&e)||0<(128&n))return void(D-=2);if(3>t)return Q(e,n);let r=x[D++];return 0<(128&r)?void(D-=3):Q(e,n,r)}if(0===t)return"";else{let e=x[D++];return 1<(128&e)?void(D-=1):Q(e)}}else{let r=x[D++],s=x[D++],a=x[D++],u=x[D++];if(0<(128&r)||0<(128&s)||0<(128&a)||0<(128&u))return void(D-=4);if(6>t){if(4===t)return Q(r,s,a,u);else{let t=x[D++];return 0<(128&t)?void(D-=5):Q(r,s,a,u,t)}}else if(8>t){let n=x[D++],e=x[D++];if(0<(128&n)||0<(128&e))return void(D-=6);if(7>t)return Q(r,s,a,u,n,e);let i=x[D++];return 0<(128&i)?void(D-=7):Q(r,s,a,u,n,e,i)}else{let d=x[D++],e=x[D++],c=x[D++],g=x[D++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&g))return void(D-=8);if(10>t){if(8===t)return Q(r,s,a,u,d,e,c,g);else{let t=x[D++];return 0<(128&t)?void(D-=9):Q(r,s,a,u,d,e,c,g,t)}}else if(12>t){let n=x[D++],i=x[D++];if(0<(128&n)||0<(128&i))return void(D-=10);if(11>t)return Q(r,s,a,u,d,e,c,g,n,i);let o=x[D++];return 0<(128&o)?void(D-=11):Q(r,s,a,u,d,e,c,g,n,i,o)}else{let p=x[D++],i=x[D++],f=x[D++],h=x[D++];if(0<(128&p)||0<(128&i)||0<(128&f)||0<(128&h))return void(D-=12);if(!(14>t)){let l=x[D++],y=x[D++];if(0<(128&l)||0<(128&y))return void(D-=14);if(15>t)return Q(r,s,a,u,d,e,c,g,p,i,f,h,l,y);let n=x[D++];return 0<(128&n)?void(D-=15):Q(r,s,a,u,d,e,c,g,p,i,f,h,l,y,n)}if(12===t)return Q(r,s,a,u,d,e,c,g,p,i,f,h);else{let t=x[D++];return 0<(128&t)?void(D-=13):Q(r,s,a,u,d,e,c,g,p,i,f,h,t)}}}}}function l(){let e,t=x[D++];if(192>t)// fixstr
e=t-160;else switch(t){case 217:e=x[D++];break;case 218:e=P.getUint16(D),D+=2;break;case 219:e=P.getUint32(D),D+=4;break;default:throw new Error("Expected string");}return a(e)}function p(e){return F.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(x,D,D+=e):x.subarray(D,D+=e)}function f(e){let t=x[D++];if(T[t])return T[t](x.subarray(D,D+=e));throw new Error("Unknown extension type "+t)}function h(){let e=x[D++];if(160<=e&&192>e){if(e-=160,j>=D)// if it has been extracted, must use it (and faster anyway)
return R.slice(D-v,(D+=e)-v);if(!(0==j&&180>E))return G(e)}else return D--,s();let t,n=4095&(e<<5^(1<e?P.getUint16(D):0<e?x[D]:0)),r=X[n],o=D,a=D+e-3,u=0;if(r&&r.bytes==e){for(;o<a;){if(t=P.getUint32(o),t!=r[u++]){o=1879048192;break}o+=4}for(a+=3;o<a;)if(t=x[o++],t!=r[u++]){o=1879048192;break}if(o===a)return D=o,r.string;a-=3,o=D}for(r=[],X[n]=r,r.bytes=e;o<a;)t=P.getUint32(o),r.push(t),o+=4;for(a+=3;o<a;)t=x[o++],r.push(t);// for small blocks, avoiding the overhead of the extract call is helpful
let d=16>e?g(e):c(e);return null==d?r.string=G(e):r.string=d}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function y(e){let t=E,n=D,r=v,s=j,i=R,o=B,a=_,u=new Uint8Array(x.slice(0,E)),d=M,c=M.slice(0,M.length),g=F,l=Y,p=e();return E=t,D=n,v=r,j=s,R=i,B=o,_=a,x=u,Y=l,M=d,M.splice(0,M.length,...c),F=g,P=new DataView(x.buffer,x.byteOffset,x.byteLength),p}function b(){x=null,B=null,M=null}function m(e){T[e.type]=e.unpack?e.unpack:e}function k(e,t,n){let r=e.byteLength;if(256>r+1){var{target:s,position:i}=n(4+r);s[i++]=199,s[i++]=r+1}else if(65536>r+1){var{target:s,position:i}=n(5+r);s[i++]=200,s[i++]=r+1>>8,s[i++]=255&r+1}else{var{target:s,position:i,targetView:o}=n(7+r);// plus one for the type byte
s[i++]=201,o.setUint32(i,r+1),i+=4}// "t" for typed array
s[i++]=116,s[i++]=t,s.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),i)}function U(e,t){let n=e.byteLength;var r,s;if(256>n){var{target:r,position:s}=t(n+2);r[s++]=196,r[s++]=n}else if(65536>n){var{target:r,position:s}=t(n+3);r[s++]=197,r[s++]=n>>8,r[s++]=255&n}else{var{target:r,position:s,targetView:i}=t(n+5);r[s++]=198,i.setUint32(s,n),s+=4}r.set(e,s)}function S(e,t,n,r){let s=e.length;return 1===s?t[n++]=212:2===s?t[n++]=213:4===s?t[n++]=214:8===s?t[n++]=215:16===s?t[n++]=216:256>s?(t[n++]=199,t[n++]=s):65536>s?(t[n++]=200,t[n++]=s>>8,t[n++]=255&s):(t[n++]=201,t[n++]=s>>24,t[n++]=255&s>>16,t[n++]=255&s>>8,t[n++]=255&s),t[n++]=r,t.set(e,n),n+=s,n}function I(e,t){// insert the ids that need to be referenced for structured clones
let n,r=6*t.length,s=e.length-r;for(t.sort((e,t)=>e.offset>t.offset?1:-1);n=t.pop();){let t=n.offset,i=n.id;e.copyWithin(t+r,t,s),r-=6;let o=t+r;// 'i'
e[o++]=214,e[o++]=105,e[o++]=i>>24,e[o++]=255&i>>16,e[o++]=255&i>>8,e[o++]=255&i,s=t}return e}function O(e,t){Ue.setUint32(Oe.position+e,Ie-Oe.position-e);let n=Oe;Oe=null,t(n[0]),t(n[1])}function A(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");pe.unshift(e.Class),le.unshift(e)}m(e)}function*w(e,t){const n=new we(t);for(const r of e)yield n.pack(r)}async function*C(e,t){const n=new we(t);for await(const r of e)yield n.pack(r)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var L;try{L=new TextDecoder}catch(e){}var x,E,M,R,_,B,P,D=0,F={},v=0,j=0,T=[],N={useRecords:!1,mapsAsObjects:!0};class V{}const W=new V;W.name="MessagePack 0xC1";var Y=!1;class z{constructor(e){e&&(!1===e.useRecords&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0)),Object.assign(this,e)}unpack(e,t){if(x)// re-entrant execution, save the state and restore it after we do this unpack
return y(()=>(b(),this?this.unpack(e,t):z.prototype.unpack.call(N,e,t)));E=-1<t?t:e.length,D=0,j=0,R=null,_=null,x=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{P=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(x=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof z){if(F=this,this.structures)return M=this.structures,n();(!M||0<M.length)&&(M=[])}else F=N,(!M||0<M.length)&&(M=[]);return n()}unpackMultiple(e,t){let r,s=0;try{Y=!0;let i=e.length,o=this?this.unpack(e,i):se.unpack(e,i);if(t){for(t(o);D<i;)if(s=D,!1===t(n()))return;}else{for(r=[o];D<i;)s=D,r.push(n());return r}}catch(e){throw e.lastPosition=s,e.values=r,e}finally{Y=!1,b()}}_mergeStructures(e,t){e=e||[];for(let n,r=0,s=e.length;r<s;r++)n=e[r],n&&(n.isShared=!0,32<=r&&(n.highByte=r-32>>5));for(let n in e.sharedLength=e.length,t||[])if(0<=n){let r=e[n],s=t[n];s&&(r&&((e.restoreStructures||(e.restoreStructures=[]))[n]=r),e[n]=s)}return this.structures=e}decode(e,t){return this.unpack(e,t)}}const $=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,q=(e,t)=>function(){let n=x[D++];if(0===n)return t();let r=32>e?-(e+(n<<5)):e+(n<<5),s=M[r]||o()[r];if(!s)throw new Error("Record id is not defined for "+r);return s.read||(s.read=i(s,e)),s.read()};var G=a,H=a,J=a,K=a;var Q=String.fromCharCode,X=Array(4096);const Z=(e,t)=>{var n=s();let r=e;void 0!==t&&(e=32>e?-((t<<5)+e):(t<<5)+e,n.highByte=t);let o=M[e];return o&&o.isShared&&((M.restoreStructures||(M.restoreStructures=[]))[e]=o),M[e]=n,n.read=i(n,r),n.read()};var ee="object"==typeof self?self:global;T[0]=()=>{},T[0].noBuffer=!0,T[101]=()=>{let e=s();return(ee[e[0]]||Error)(e[1])},T[105]=()=>{// id extension (for structured clones)
let e=P.getUint32(D-4);B||(B=new Map);let t,n=x[D];t=144<=n&&160>n||220==n||221==n?[]:{};let r={target:t};// a placeholder object
B.set(e,r);let i=s();// read the next value as the target object to id
return r.used?Object.assign(t,i):(r.target=i,i);// no cycle, can just use the returned read object
},T[112]=()=>{// pointer extension (for structured clones)
let e=P.getUint32(D-4),t=B.get(e);return t.used=!0,t.target},T[115]=()=>new Set(s());const te=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(e=>e+"Array");T[116]=e=>{let t=e[0],n=te[t];if(!n)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new ee[n](Uint8Array.prototype.slice.call(e,1).buffer)},T[120]=()=>{let e=s();return new RegExp(e[0],e[1])};const ne=[];T[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=D;return D+=t-e.length,_=ne,_=[l(),l()],_.position0=0,_.position1=0,_.postBundlePosition=D,D=n,s()},T[255]=e=>4==e.length?new Date(1e3*(16777216*e[0]+(e[1]<<16)+(e[2]<<8)+e[3])):8==e.length?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+1e3*(4294967296*(3&e[3])+16777216*e[4]+(e[5]<<16)+(e[6]<<8)+e[7])):12==e.length?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+1e3*((128&e[4]?-281474976710656:0)+1099511627776*e[6]+4294967296*e[7]+16777216*e[8]+(e[9]<<16)+(e[10]<<8)+e[11])):new Date("invalid");const re=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let n=0;256>n;n++)re[n]=+("1e"+t(45.15-.30103*n));var se=new z({useRecords:!1});const ie=se.unpack,oe=se.unpackMultiple,ae=se.unpack,ue={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let de,ce=new Float32Array(1),ge=new Uint8Array(ce.buffer,0,4);try{de=new TextEncoder}catch(e){}let le,pe;const fe="undefined"!=typeof Buffer,he=fe?Buffer.allocUnsafeSlow:Uint8Array,ye=fe?Buffer:Uint8Array,be=fe?4294967296:2144337920;let me,ke,Ue,Se,Ie=0,Oe=null;const Ae=Symbol("record-id");class we extends z{constructor(e){super(e),this.offset=0;let t,n,r,s,i,o=0,a=ye.prototype.utf8Write?function(e,t,n){return me.utf8Write(e,t,n)}:!!(de&&de.encodeInto)&&function(e,t){return de.encodeInto(e,me.subarray(t)).written},u=this;e||(e={});let d=e&&e.sequential,c=e.structures||e.saveStructures,g=e.maxSharedStructures;if(null==g&&(g=c?32:0),8160<g)throw new Error("Maximum maxSharedStructure is 8160");let l=e.maxOwnStructures;null==l&&(l=c?32:64),d&&!e.saveStructures&&(this.structures=[]);// two byte record ids for shared structures
let p=32<g||64<l+g,f=g+64,h=g+l+64;if(8256<h)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let y=[],b=0,m=0;this.pack=this.encode=function(e,a){if(me||(me=new he(8192),Ue=new DataView(me.buffer,0,8192),Ie=0),Se=me.length-10,2048>Se-Ie?(me=new he(me.length),Ue=new DataView(me.buffer,0,me.length),Se=me.length-10,Ie=0):Ie=2147483640&Ie+7,t=Ie,i=u.structuredClone?new Map:null,u.bundleStrings&&"string"!=typeof e?(Oe=[],Oe.size=1/0):Oe=null,n=u.structures,n){n.uninitialized&&(n=u._mergeStructures(u.getStructures()));let e=n.sharedLength||0;if(e>g)//if (maxSharedStructures <= 32 && sharedStructures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+n.sharedLength);if(!n.transitions){n.transitions=Object.create(null);for(let t,r=0;r<e;r++){if(t=n[r],!t)continue;let e,s=n.transitions;for(let n,r=0,i=t.length;r<i;r++)n=t[r],e=s[n],e||(e=s[n]=Object.create(null)),s=e;s[Ae]=r+64}o=e}d||(n.nextId=e+64)}r&&(r=!1),s=n||(u.structures=[]);try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(k(e),Oe&&O(t,k),u.offset=Ie,i&&i.idsToInsert){Ie+=6*i.idsToInsert.length,Ie>Se&&A(Ie),u.offset=Ie;let e=I(me.subarray(t,Ie),i.idsToInsert);return i=null,e}return a&Be?(me.start=t,me.end=Ie,me):me.subarray(t,Ie);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(n){if(10>m&&m++,n.length>g&&(n.length=g),1e4<b)n.transitions=null,m=0,b=0,0<y.length&&(y=[]);else if(0<y.length&&!d){for(let e=0,t=y.length;e<t;e++)y[e][Ae]=0;y=[]}if(r&&u.saveStructures){let r=n.sharedLength||g;n.length>r&&(n=n.slice(0,r));// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let s=me.subarray(t,Ie);return!1===u.saveStructures(n,o)?(u._mergeStructures(u.getStructures()),u.pack(e)):(o=r,s)}}a&Pe&&(Ie=t)}};const k=e=>{Ie>Se&&(me=A(Ie));var n,r=typeof e;if("string"==r){let r=e.length;if(Oe&&4<=r&&4096>r){if((Oe.size+=r)>61440){let e,n=(Oe[0]?3*Oe[0].length+Oe[1].length:0)+10;Ie+n>Se&&(me=A(Ie+n)),Oe.position?(me[Ie]=200,Ie+=3,me[Ie++]=98,e=Ie-t,Ie+=4,O(t,k),Ue.setUint16(e+t-3,Ie-t-e)):(me[Ie++]=214,me[Ie++]=98,e=Ie-t,Ie+=4),Oe=["",""],Oe.size=0,Oe.position=e}let n=/[\u0080-\uFFFF]/.test(e);return Oe[n?0:1]+=e,me[Ie++]=193,void k(n?-r:r)}let s=32>r?1:256>r?2:65536>r?3:5;// first we estimate the header size, so we can write to the correct location
let i=3*r;if(Ie+i>Se&&(me=A(Ie+i)),64>r||!a){let t,i,o,a=Ie+s;for(t=0;t<r;t++)i=e.charCodeAt(t),128>i?me[a++]=i:2048>i?(me[a++]=192|i>>6,me[a++]=128|63&i):55296==(64512&i)&&56320==(64512&(o=e.charCodeAt(t+1)))?(i=65536+((1023&i)<<10)+(1023&o),t++,me[a++]=240|i>>18,me[a++]=128|63&i>>12,me[a++]=128|63&i>>6,me[a++]=128|63&i):(me[a++]=224|i>>12,me[a++]=128|63&i>>6,me[a++]=128|63&i);n=a-Ie-s}else n=a(e,Ie+s,i);32>n?me[Ie++]=160|n:256>n?(2>s&&me.copyWithin(Ie+2,Ie+1,Ie+1+n),me[Ie++]=217,me[Ie++]=n):65536>n?(3>s&&me.copyWithin(Ie+3,Ie+2,Ie+2+n),me[Ie++]=218,me[Ie++]=n>>8,me[Ie++]=255&n):(5>s&&me.copyWithin(Ie+5,Ie+3,Ie+3+n),me[Ie++]=219,Ue.setUint32(Ie,n),Ie+=4),Ie+=n}else if("number"===r){if(e>>>0===e)64>e?me[Ie++]=e:256>e?(me[Ie++]=204,me[Ie++]=e):65536>e?(me[Ie++]=205,me[Ie++]=e>>8,me[Ie++]=255&e):(me[Ie++]=206,Ue.setUint32(Ie,e),Ie+=4);else if(e>>0===e)-32<=e?me[Ie++]=256+e:-128<=e?(me[Ie++]=208,me[Ie++]=e+256):-32768<=e?(me[Ie++]=209,Ue.setInt16(Ie,e),Ie+=2):(me[Ie++]=210,Ue.setInt32(Ie,e),Ie+=4);else{let t;if(0<(t=this.useFloat32)&&4294967296>e&&-2147483648<=e){me[Ie++]=202,Ue.setFloat32(Ie,e);let n;if(4>t||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(n=e*re[(127&me[Ie])<<1|me[Ie+1]>>7])>>0===n)return void(Ie+=4);// move back into position for writing a double
Ie--}me[Ie++]=203,Ue.setFloat64(Ie,e),Ie+=8}}else if("object"===r){if(!e)me[Ie++]=192;else{if(i){let n=i.get(e);if(n){if(!n.id){let e=i.idsToInsert||(i.idsToInsert=[]);n.id=e.push(n)}return me[Ie++]=214,me[Ie++]=112,Ue.setUint32(Ie,n.id),void(Ie+=4)}i.set(e,{offset:Ie-t})}let r=e.constructor;if(r===Object)U(e,!0);else if(r===Array){n=e.length,16>n?me[Ie++]=144|n:65536>n?(me[Ie++]=220,me[Ie++]=n>>8,me[Ie++]=255&n):(me[Ie++]=221,Ue.setUint32(Ie,n),Ie+=4);for(let t=0;t<n;t++)k(e[t])}else if(r===Map){n=e.size,16>n?me[Ie++]=128|n:65536>n?(me[Ie++]=222,me[Ie++]=n>>8,me[Ie++]=255&n):(me[Ie++]=223,Ue.setUint32(Ie,n),Ie+=4);for(let[t,n]of e)k(t),k(n)}else{for(let t,n=0,r=le.length;n<r;n++)if(t=pe[n],e instanceof t){let t=le[n];if(t.write)return t.type&&(me[Ie++]=212,me[Ie++]=t.type,me[Ie++]=0),void k(t.write.call(this,e));let r=me,s=Ue,i=Ie;me=null;let o;try{o=t.pack.call(this,e,e=>(me=r,r=null,Ie+=e,Ie>Se&&A(Ie),{target:me,targetView:Ue,position:Ie-e}),k)}finally{r&&(me=r,Ue=s,Ie=i,Se=me.length-10)}return void(o&&(o.length+Ie>Se&&A(o.length+Ie),Ie=S(o,me,Ie,t.type)))}// no extension found, write as object
U(e,!e.hasOwnProperty)}}}else if("boolean"===r)me[Ie++]=e?195:194;else if("bigint"===r){if(e<BigInt(1)<<BigInt(63)&&e>=-(BigInt(1)<<BigInt(63)))me[Ie++]=211,Ue.setBigInt64(Ie,e);else if(e<BigInt(1)<<BigInt(64)&&0<e)me[Ie++]=207,Ue.setBigUint64(Ie,e);else// overflow
if(this.largeBigIntToFloat)me[Ie++]=203,Ue.setFloat64(Ie,+e);else throw new RangeError(e+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");Ie+=8}else if("undefined"===r)this.encodeUndefinedAsNil?me[Ie++]=192:(me[Ie++]=212,me[Ie++]=0,me[Ie++]=0);else if("function"===r)k(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+r)},U=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),n=t.length;16>n?me[Ie++]=128|n:65536>n?(me[Ie++]=222,me[Ie++]=n>>8,me[Ie++]=255&n):(me[Ie++]=223,Ue.setUint32(Ie,n),Ie+=4);let r;for(let s=0;s<n;s++)k(r=t[s]),k(e[r])}:(e,n)=>{me[Ie++]=222;// always using map 16, so we can preallocate and set the length afterwards
let r=Ie-t;Ie+=2;let s=0;for(let t in e)(n||e.hasOwnProperty(t))&&(k(t),k(e[t]),s++);me[r++ +t]=s>>8,me[r+t]=255&s}:e.progressiveRecords&&!p?// this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
(e,n)=>{let r,i,o=s.transitions||(s.transitions=Object.create(null)),a=Ie++-t;for(let u in e)if(n||e.hasOwnProperty(u)){if(r=o[u],r)o=r;else{// record doesn't exist, create full new record and insert it
let n=Object.keys(e),d=o;o=s.transitions;let c=0;for(let e,t=0,s=n.length;t<s;t++)e=n[t],r=o[e],r||(r=o[e]=Object.create(null),c++),o=r;a+t+1==Ie?(Ie--,w(o,n,c)):// otherwise we need to insert the record, moving existing data after the record
C(o,n,a,c),i=!0,o=d[u]}k(e[u])}if(!i){let n=o[Ae];n?me[a+t]=n:C(o,Object.keys(e),a,0)}}:(e,t)=>{let n,r=s.transitions||(s.transitions=Object.create(null)),i=0;for(let s in e)(t||e.hasOwnProperty(s))&&(n=r[s],n||(n=r[s]=Object.create(null),i++),r=n);let o=r[Ae];// now write the values
for(let n in o?96<=o&&p?(me[Ie++]=(31&(o-=96))+96,me[Ie++]=o>>5):me[Ie++]=o:w(r,r.__keys__||Object.keys(e),i),e)(t||e.hasOwnProperty(n))&&k(e[n])},A=e=>{var n=Math.min,r=Math.round,s=Math.max;let i;if(16777216<e){// special handling for really large buffers
if(e-t>be)throw new Error("Packed buffer would be larger than maximum buffer size");i=n(be,4096*r(s((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
i=(s(e-t<<2,me.length-1)>>12)+1<<12;let o=new he(i);return Ue=new DataView(o.buffer,0,i),me.copy?me.copy(o,0,t,e):o.set(me.slice(t,e)),Ie-=t,t=0,Se=o.length-10,me=o},w=(e,t,n)=>{let i=s.nextId;i||(i=64),i<f&&this.shouldShareStructure&&!this.shouldShareStructure(t)?(i=s.nextOwnId,!(i<h)&&(i=f),s.nextOwnId=i+1):(i>=h&&(// cycle back around
i=f),s.nextId=i+1);let o=t.highByte=96<=i&&p?i-96>>5:-1;e[Ae]=i,e.__keys__=t,s[i-64]=t,i<f?(t.isShared=!0,s.sharedLength=i-63,r=!0,0<=o?(me[Ie++]=(31&i)+96,me[Ie++]=o):me[Ie++]=i):(0<=o?(me[Ie++]=213,me[Ie++]=114,me[Ie++]=(31&i)+96,me[Ie++]=o):(me[Ie++]=212,me[Ie++]=114,me[Ie++]=i),n&&(b+=m*n),y.length>=l&&(y.shift()[Ae]=0),y.push(e),k(t))},C=(e,n,r,s)=>{let i=me,o=Ie,a=Se,u=t;me=ke,Ie=0,t=0,me||(ke=me=new he(8192)),Se=me.length-10,w(e,n,s),ke=me;let d=Ie;if(me=i,Ie=o,Se=a,t=u,1<d){let e=Ie+d-1;e>Se&&A(e);let n=r+t;me.copyWithin(n+d,n+1,Ie),me.set(ke.slice(0,d),n),Ie=e}else me[r+t]=ke[0]}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
me=e,Ue=new DataView(me.buffer,me.byteOffset,me.byteLength),Ie=0}clearSharedData(){this.structures&&(this.structures=[])}}pe=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,V],le=[{pack(e,n,r){let s=e.getTime()/1e3;if((this.useTimestamp32||0===e.getMilliseconds())&&0<=s&&4294967296>s){// Timestamp 32
let{target:e,targetView:t,position:r}=n(6);e[r++]=214,e[r++]=255,t.setUint32(r,s)}else if(0<s&&17179869184>s){// Timestamp 64
let{target:t,targetView:r,position:i}=n(10);t[i++]=215,t[i++]=255,r.setUint32(i,4e6*e.getMilliseconds()+(s/1e3/4294967296>>0)),r.setUint32(i+4,s)}else if(isNaN(s)){if(this.onInvalidDate)return n(0),r(this.onInvalidDate());// Intentionally invalid timestamp
let{target:e,targetView:t,position:s}=n(3);e[s++]=212,e[s++]=255,e[s++]=255}else{// Timestamp 96
let{target:r,targetView:i,position:o}=n(15);r[o++]=199,r[o++]=12,r[o++]=255,i.setUint32(o,1e6*e.getMilliseconds()),i.setBigInt64(o+4,BigInt(t(s)))}}},{pack(e,t,n){let r=Array.from(e),{target:s,position:i}=t(this.structuredClone?3:0);this.structuredClone&&(s[i++]=212,s[i++]=115,s[i++]=0),n(r)}},{pack(e,t,n){let{target:r,position:s}=t(this.structuredClone?3:0);this.structuredClone&&(r[s++]=212,r[s++]=101,r[s++]=0),n([e.name,e.message])}},{pack(e,t,n){let{target:r,position:s}=t(this.structuredClone?3:0);this.structuredClone&&(r[s++]=212,r[s++]=120,r[s++]=0),n([e.source,e.flags])}},{pack(e,t){this.structuredClone?k(e,16,t):U(fe?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==ye&&this.structuredClone?k(e,te.indexOf(n.name),t):U(e,t)}},{pack(e,t){// specific 0xC1 object
let{target:n,position:r}=t(1);n[r]=193}}];let Ce=new we({useRecords:!1});const Le=Ce.pack,xe=Ce.pack,{NEVER:Ee,ALWAYS:Me,DECIMAL_ROUND:Re,DECIMAL_FIT:_e}=ue,Be=512,Pe=1024;e.ALWAYS=Me,e.C1=W,e.DECIMAL_FIT=_e,e.DECIMAL_ROUND=Re,e.Decoder=z,e.Encoder=we,e.FLOAT32_OPTIONS=ue,e.NEVER=Ee,e.Packr=we,e.REUSE_BUFFER_MODE=Be,e.Unpackr=z,e.addExtension=A,e.clearSource=b,e.decode=ae,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new z(t);let r;const s=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
r&&(e=Buffer.concat([r,e]),r=void 0);try{t=n.unpackMultiple(e)}catch(n){if(n.incomplete)r=e.slice(n.lastPosition),t=n.values;else throw n}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*s(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*s(t)}():void 0},e.encode=xe,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return w(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return C(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.mapsAsObjects=!0,e.pack=Le,e.roundFloat32=function(e){ce[0]=e;let t=re[(127&ge[3])<<1|ge[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},e.unpack=ie,e.unpackMultiple=oe,e.useRecords=!1,Object.defineProperty(e,"__esModule",{value:!0})});
